<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《深入浅出 RxJS》笔记 | tangdw</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/logo.jpg">
    <link rel="manifest" href="/manifest.json">
    <meta name="description" content="">
    <meta name="theme-color" content="#f22148">
    
    <link rel="preload" href="/assets/css/0.styles.3f503044.css" as="style"><link rel="preload" href="/assets/js/app.da05fdbf.js" as="script"><link rel="preload" href="/assets/js/2.208295da.js" as="script"><link rel="preload" href="/assets/js/17.eafc6cc3.js" as="script"><link rel="preload" href="/assets/js/5.b3cdef39.js" as="script"><link rel="prefetch" href="/assets/js/10.874c21b1.js"><link rel="prefetch" href="/assets/js/11.06584f03.js"><link rel="prefetch" href="/assets/js/12.a5c8c05f.js"><link rel="prefetch" href="/assets/js/13.1b507851.js"><link rel="prefetch" href="/assets/js/14.c27a0ed9.js"><link rel="prefetch" href="/assets/js/15.fae66cfd.js"><link rel="prefetch" href="/assets/js/16.8b83fc5b.js"><link rel="prefetch" href="/assets/js/18.f7675d14.js"><link rel="prefetch" href="/assets/js/19.aa19b35f.js"><link rel="prefetch" href="/assets/js/20.af217273.js"><link rel="prefetch" href="/assets/js/21.8ddc378c.js"><link rel="prefetch" href="/assets/js/22.36e77ad8.js"><link rel="prefetch" href="/assets/js/23.5a61c462.js"><link rel="prefetch" href="/assets/js/24.582c1b00.js"><link rel="prefetch" href="/assets/js/25.eda3379a.js"><link rel="prefetch" href="/assets/js/26.8e4cbbe9.js"><link rel="prefetch" href="/assets/js/27.03cb3422.js"><link rel="prefetch" href="/assets/js/28.645ce61e.js"><link rel="prefetch" href="/assets/js/29.f897465a.js"><link rel="prefetch" href="/assets/js/3.967895da.js"><link rel="prefetch" href="/assets/js/30.d2934177.js"><link rel="prefetch" href="/assets/js/31.42258174.js"><link rel="prefetch" href="/assets/js/32.f7b5e341.js"><link rel="prefetch" href="/assets/js/33.362b0b71.js"><link rel="prefetch" href="/assets/js/34.91512baa.js"><link rel="prefetch" href="/assets/js/35.e51fc052.js"><link rel="prefetch" href="/assets/js/36.41c20116.js"><link rel="prefetch" href="/assets/js/37.e90f6066.js"><link rel="prefetch" href="/assets/js/38.3878636b.js"><link rel="prefetch" href="/assets/js/39.f310c7d2.js"><link rel="prefetch" href="/assets/js/4.9f3812bd.js"><link rel="prefetch" href="/assets/js/40.c1e2ee49.js"><link rel="prefetch" href="/assets/js/41.cf733c7c.js"><link rel="prefetch" href="/assets/js/42.ef868d9d.js"><link rel="prefetch" href="/assets/js/43.8478bfa6.js"><link rel="prefetch" href="/assets/js/44.dd9a1d85.js"><link rel="prefetch" href="/assets/js/45.d014f7a8.js"><link rel="prefetch" href="/assets/js/46.205be7a4.js"><link rel="prefetch" href="/assets/js/47.a942e446.js"><link rel="prefetch" href="/assets/js/48.f11dc1c7.js"><link rel="prefetch" href="/assets/js/49.30f1d0d9.js"><link rel="prefetch" href="/assets/js/50.ad3da487.js"><link rel="prefetch" href="/assets/js/51.6685e327.js"><link rel="prefetch" href="/assets/js/52.6f6c68f4.js"><link rel="prefetch" href="/assets/js/53.4acba881.js"><link rel="prefetch" href="/assets/js/54.609dd144.js"><link rel="prefetch" href="/assets/js/6.b8f3f640.js"><link rel="prefetch" href="/assets/js/7.2e8acf8c.js"><link rel="prefetch" href="/assets/js/8.cd73e5c7.js"><link rel="prefetch" href="/assets/js/9.ba0911e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3f503044.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">tangdw</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/书签.html" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/shell.html" class="nav-link">
  Shell
</a></div><div class="nav-item"><a href="/nestjs.html" class="nav-link">
  Nestjs
</a></div><div class="nav-item"><a href="/golang.html" class="nav-link">
  golang
</a></div><div class="nav-item"><a href="/life/传习录.html" class="nav-link">
  My Life
</a></div> <a href="https://github.com/tangdw" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/书签.html" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/shell.html" class="nav-link">
  Shell
</a></div><div class="nav-item"><a href="/nestjs.html" class="nav-link">
  Nestjs
</a></div><div class="nav-item"><a href="/golang.html" class="nav-link">
  golang
</a></div><div class="nav-item"><a href="/life/传习录.html" class="nav-link">
  My Life
</a></div> <a href="https://github.com/tangdw" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Blog</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/书签.html" class="sidebar-link">我的书签</a></li><li><a href="/blog/刷面试题.html" class="sidebar-link">面试复习</a></li><li><a href="/blog/《算法图解》笔记.html" class="sidebar-link">《算法图解》笔记</a></li><li><a href="/blog/React 扫盲.html" class="sidebar-link">React 扫盲</a></li><li><a href="/blog/Mobx 扫盲.html" class="sidebar-link">Mobx 扫盲</a></li><li><a href="/blog/Typescript 扫盲.html" class="sidebar-link">Typescript 扫盲</a></li><li><a href="/blog/RxJS 笔记.html" class="active sidebar-link">《深入浅出 RxJS》笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#函数反应式编程-frp" class="sidebar-link">函数反应式编程 FRP</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#rxjs-基础知识" class="sidebar-link">RxJS 基础知识</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#操作符基础" class="sidebar-link">操作符基础</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#创建数据流" class="sidebar-link">创建数据流</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#合并数据流" class="sidebar-link">合并数据流</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#辅助类操作符" class="sidebar-link">辅助类操作符</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#过滤数据流" class="sidebar-link">过滤数据流</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#转化数据流" class="sidebar-link">转化数据流</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#异常错误处理" class="sidebar-link">异常错误处理</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#多播" class="sidebar-link">多播</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#掌握时间的-scheduler" class="sidebar-link">掌握时间的 Scheduler</a></li><li class="sidebar-sub-header"><a href="/blog/RxJS 笔记.html#rxjs-调试和测试" class="sidebar-link">RxJS 调试和测试</a></li></ul></li><li><a href="/blog/PWA.html" class="sidebar-link">PWA 相关知识点</a></li><li><a href="/blog/性能优化.html" class="sidebar-link">性能方面</a></li><li><a href="/blog/各种小技巧.html" class="sidebar-link">各种小技巧</a></li><li><a href="/blog/eslint + prettier.html" class="sidebar-link">eslint + pretier</a></li><li><a href="/blog/antd 树形 table 组件.html" class="sidebar-link">antd 树形 table 实现父子联动选择</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="《深入浅出-rxjs》笔记"><a href="#《深入浅出-rxjs》笔记" aria-hidden="true" class="header-anchor">#</a> 《深入浅出 RxJS》笔记</h1> <blockquote><p>RxJS 兼具函数式和反应式编程特点，擅长处理异步操作，因为它对数据采用 “推” 的处理方式，当一个数据产生的时候，会被推送给对应的处理函数，这个函数不用关心数据是同步产生还是异步产生的。</p></blockquote> <h2 id="函数反应式编程-frp"><a href="#函数反应式编程-frp" aria-hidden="true" class="header-anchor">#</a> 函数反应式编程 FRP</h2> <ul><li>问题
<ul><li>如何控制大量代码的复杂度</li> <li>如何保持代码的可读性/可维护性</li> <li>如何处理异步操作</li></ul></li> <li>函数式编程特征
<ul><li>声明式（对应命令式）
<ul><li>不直接操作数据，以传递函数类型的参数来封装功能（只需表达想要做什么，而不是怎么去做）</li></ul></li> <li>纯函数
<ul><li>函数的执行结果完全由输入参数决定，不会受除参数之外的任何数据影响</li> <li>函数内不会修改任何外部状态（如引用类型的参数属性）</li></ul></li> <li>数据不可变性
<ul><li>不要去修改现有数据，而是产生一个新的数据来体现 “程序的功能”</li></ul></li></ul></li> <li>反应式编程
<ul><li>Rx 是一套通过监听流（程序的输入可以看成是一个数据流）来做异步编程的 API</li> <li>Rx 诞生的主要目的是解决异步问题，而实际上使用 RxJS 通常不需要关心自己是被同步执行还是异步执行
<ul><li>数据流抽象了很多现实问题</li> <li>擅长处理异步操作</li> <li>把复杂问题分解成简单的问题组合
<ul><li>实现某个小功能的函数就是操作符</li> <li>RxJS 就是学习如何组合操作符来解决复杂问题</li></ul></li></ul></li></ul></li></ul> <h2 id="rxjs-基础知识"><a href="#rxjs-基础知识" aria-hidden="true" class="header-anchor">#</a> RxJS 基础知识</h2> <blockquote><p><code>tree-shaking</code> 可以处理 <code>import</code> 方式的导入，最好是用一个文件专门导入 RxJS 相关功能，然后再在入口导入这个文件</p></blockquote> <ul><li><p><code>Observable</code> 是可被观察者（数据流），<code>Observer</code> 是观察者</p> <ul><li><p>代表 “流” 的变量标识符都以 $ 符号结尾（芬兰式命名法）</p> <ul><li>数据流相对于数组有个好处，就是如果有个永无止境的数据流，内存不会无限增加</li></ul></li> <li><p>连接两者的桥梁就是 <code>Observable</code> 对象的函数 <code>subscribe</code>，而 <code>Observer</code> 作为这个函数的参数</p> <ul><li>如何产生事件 -&gt; <code>Observable</code> -&gt; 发布者</li> <li>如何响应事件 -&gt; <code>Observer</code> -&gt; 观察者</li> <li>什么样的发布者关联什么样的观察者 -&gt; 何时调用 <code>subscribe</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> 'rxjs<span class="token operator">/</span>Observable
<span class="token keyword">const</span> <span class="token function-variable function">onSubscribe</span> <span class="token operator">=</span> <span class="token parameter">observer</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 把数据 “推给” observer</span>
  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  <span class="token comment">// observer.error('err') // 通知出错 -&gt; 弹珠图表示符号 X</span>
  <span class="token comment">// observer.complete() // 通知完结 -&gt; 弹珠图表示符号 |</span>
  <span class="token comment">// 以上终结状态 error complete 只要其中一个被调用，后面的都不会执行了</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token comment">// 退订时</span>
    <span class="token function-variable function">unsubscribe</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 清除定时器之类的。。。</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> source$ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span>onSubscribe<span class="token punctuation">)</span>
<span class="token comment">// 这里并不是直接传给 onSubscribe，而是被包装过的</span>
<span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">next</span><span class="token punctuation">:</span> <span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 只有 next 是必须</span>
  <span class="token function-variable function">error</span><span class="token punctuation">:</span> <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">complete</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// subscribe 参数是观察者，可以用对象形式</span>
<span class="token comment">// 也可以用多参形式：(nextFn, errorFn, completeFn)</span>
<span class="token comment">// 只有 subscribe 被调用时，onSubscribe 才执行，observer 才响应</span>
<span class="token keyword">const</span> subscription <span class="token operator">=</span> source$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span>
<span class="token comment">// 观察者退订 - 终端 observer 与 source$ 的连接</span>
<span class="token comment">// -&gt; observer 不会再响应了，但 source$ 还有可能继续发射</span>
subscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li></ul></li> <li><p>Hot Cold Observable</p> <ul><li>有多个观察者在不同时间订阅的情况下，是否响应之前时间产生的数据</li> <li>Cold -&gt; “点播” 每次 <code>subscribe</code> 都产生一个心的生产者</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> clod <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">observer</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 产生新的生产者 - 新启动 - 冷 -_-</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>Hot -&gt; “直播”</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 生产者 - 已启动 - 热</span>
<span class="token keyword">const</span> clod <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">observer</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>操作符：对数据流进行创建/处理/转化（静态方法、实例方法）的函数</p></li></ul> <h2 id="操作符基础"><a href="#操作符基础" aria-hidden="true" class="header-anchor">#</a> 操作符基础</h2> <blockquote><p>返回一个 Observable 对象、对上游和下游的订阅及退订处理、处理异常境况、及时释放资源</p></blockquote> <ul><li><p>（按输入）返回一个 Observable 对象的函数</p> <ol><li>根据其他 Observable 对象产生 -&gt; 实例
<blockquote><p><code>import 'rxjs/add/operators/map'</code></p></blockquote></li> <li>利用其他类型的输入产生 -&gt; 静态
<blockquote><p><code>import 'rxjs/add/observable/of'</code></p></blockquote></li> <li>不需要输入可以凭空产生 -&gt; 静态
<blockquote><p><code>Observable.create(...)</code></p></blockquote></li> <li>静态操作符只能出现在链式调用的首位，有些操作符既有静态类也有实例类</li></ol></li> <li><p>pipeable 操作符 通过 pipe 串接，有利于 tree shaking</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span><span class="token keyword">of</span><span class="token punctuation">}</span> <span class="token keyword">from</span> 'rxjs<span class="token operator">/</span>add<span class="token operator">/</span>observable<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>map<span class="token punctuation">,</span> filter<span class="token punctuation">}</span> <span class="token keyword">from</span> 'rxjs<span class="token operator">/</span>add<span class="token operator">/</span>operators<span class="token punctuation">;</span>

<span class="token keyword">const</span> source$ <span class="token operator">=</span> <span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> res$ <span class="token operator">=</span> source$<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
  <span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div></li></ul> <h2 id="创建数据流"><a href="#创建数据流" aria-hidden="true" class="header-anchor">#</a> 创建数据流</h2> <blockquote><p>不依赖其他 Observable 对象产生 Observable</p></blockquote> <table><thead><tr><th>功能需求</th> <th>适用的操作符</th></tr></thead> <tbody><tr><td>直接操作<strong>观察者</strong></td> <td>create(observer =&gt; {...})</td></tr> <tr><td>根据有限的数据产生<strong>同步数据流</strong></td> <td>of(1, 2, 3)</td></tr> <tr><td>产生一个数值范围内的数据</td> <td>range(1, 100)</td></tr> <tr><td>以循环方是产生数据</td> <td>generate</td></tr> <tr><td>重复产生数据流中的数据</td> <td>repeat 和 repeatWhen</td></tr> <tr><td>产生空数据流</td> <td>empty -&gt; 直接产生一个完结（complete）的 Observable 对象</td></tr> <tr><td>产生直接出错的数据流</td> <td>throw -&gt; 直接 error</td></tr> <tr><td>产生永不完结的数据流</td> <td>never -&gt; 永不 complete 或 error</td></tr> <tr><td>间隔给定时间持续产生</td> <td>interval 和 time</td></tr> <tr><td>从数组等<strong>枚举</strong>类型数据产生数据流</td> <td>from(数组、字符串、generator、arguments)</td></tr> <tr><td>从 Promise 对象产生数据流</td> <td>fromPromise</td></tr> <tr><td>从外部事件对象产生数据流</td> <td>fromEvent 和 fromEventPattern</td></tr> <tr><td>从 ajax 请求结果产生数据流</td> <td>ajax</td></tr> <tr><td>延迟产生数据流</td> <td>defer() 参数是</td></tr></tbody></table> <h3 id="创建同步数据流"><a href="#创建同步数据流" aria-hidden="true" class="header-anchor">#</a> 创建同步数据流</h3> <ul><li><p>generate -&gt; 类似 for 循环</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i <span class="token operator">*</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// ---- 对照 ----</span>
<span class="token keyword">const</span> res$ <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span>
  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// let i = 0</span>
  <span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> i<span class="token operator">++</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> i <span class="token operator">*</span> i
<span class="token punctuation">)</span>
</code></pre></div></li> <li><p><code>repeat(2)</code> -&gt; 上游 <code>complete</code> 之后再重复 -&gt; 被订阅 2 次，也被退订 2 次</p></li></ul> <h3 id="创建异步数据流"><a href="#创建异步数据流" aria-hidden="true" class="header-anchor">#</a> 创建异步数据流</h3> <ul><li><p>interval(1000) -&gt; setInterval -&gt; . 0 . 1 . 2 ...</p></li> <li><p>time(1000) -&gt; setTimeout -&gt; . 0</p> <ul><li>time 第二个参数作用同 interval 所以 time 是 interval 超集</li></ul></li> <li><p>fromEvent</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> evt$ <span class="token operator">=</span> <span class="token function">fromEvent</span><span class="token punctuation">(</span>dom<span class="token punctuation">,</span> <span class="token string">'click/mousemove'</span><span class="token punctuation">)</span>
<span class="token comment">// 也可以是自定义 event 和 action</span>
</code></pre></div></li> <li><p>fromEventPattern(addHandler, removeHandler)</p> <ul><li><code>addHandler</code>, <code>removeHandler</code> 函数表示添加、移除事件的动作（无需传入事件对象）</li> <li>当 Observable 对象调用 subscribe 时 <code>addHandler</code> 被调用</li> <li>Observable 调用 subscribe 的返回值再调用 unsubscribe 时 <code>removeHandler</code> 被调用</li></ul></li> <li><p>repeatWhen 相对于 repeat 来说还可以控制再次订阅的时间</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">notifier</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">notification$</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> notification$<span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// 上游完结后 1s 之后再重新订阅</span>
  <span class="token comment">// return 一个 Observable 通知重新订阅</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> repeated$ <span class="token operator">=</span> source$<span class="token punctuation">.</span><span class="token function">repeateWhen</span><span class="token punctuation">(</span>notifier<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>defer 延迟产生 Observable</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">observableFa</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Observable<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span>ajaxUrl<span class="token punctuation">)</span>
<span class="token keyword">const</span> source$ <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span>observableFa<span class="token punctuation">)</span>
<span class="token comment">// 只有在 source$ 被订阅时 observableFa 才会被调用</span>
</code></pre></div></li></ul> <h2 id="合并数据流"><a href="#合并数据流" aria-hidden="true" class="header-anchor">#</a> 合并数据流</h2> <blockquote><p>把多个 Observable 对象合并到 一个 Observable 中</p></blockquote> <table><thead><tr><th>功能需求</th> <th>适用的操作符</th></tr></thead> <tbody><tr><td>把多个数据流以<strong>首尾相连</strong>的方式合并</td> <td>concat 和 concatAll</td></tr> <tr><td>把多个数据流以<strong>先到先得</strong>的方式合并</td> <td>merge 和 mergeAll</td></tr> <tr><td>把多个数据流以<strong>一对一</strong>的方式合并</td> <td>zip 和 zipAll</td></tr> <tr><td>持续合并多个数据流中<strong>最新产生</strong>的数据</td> <td>combineLatest combineAll withLatestFrom</td></tr> <tr><td>从多个数据流中选取<strong>第一个产生内容</strong>的数据流</td> <td>race</td></tr> <tr><td>在数据流<strong>前面添加一个</strong>指定数据</td> <td>startWith</td></tr> <tr><td>只获取多个数据流<strong>最后产生</strong>的那个数据</td> <td>forkJoin</td></tr> <tr><td>从高阶数据流中切换数据源</td> <td>switch exhaust</td></tr></tbody></table> <ul><li><code>concat</code> 从 source1$ 中获取数据并传给下游，当 source1$ complete 之后，就会调用 source1$.unsubscribe 然后调用 source2$.subscribe 继续从 source2$ 获取数据并传给下游</li> <li><code>merge</code> 会第一时间订阅所有上游 Observable 任何一个上游 Observable 有数据了就立刻传给下游，所有上游都 complete 时，下游 Observable 才会 complete
<blockquote><p>避免使用 merge 去合并同步数据流，因为上游同步数据是一下子全传给下游的，和 concat 差不多了</p></blockquote></li> <li><code>zip</code> 把上游的数据转化为数组形式传给下游，每个上游 Observable 产生的数据，都会在对应的数组中有一席之地。只要任意一个上游 complete 且这个 Observable 最后产生的数据也配对之后就把这最后一个数组传给下游同时下游 Observable 也 complete</li> <li><code>combineLatest</code> 合并上游产生的最新的数据，从所有上游都有数据产生开始，只要任意一个上游的发出新的数据，都会合并一次传给下游。所有上游都完结之后（不会再有新发出数据）时，下游也就完结了
<ul><li>combineLatest 的第二个参数是函数，用于&quot;定义合并&quot;这个操作，可以不必传数组给下游</li></ul></li> <li><code>withLatestFrom</code> 与 combineLatest 不同的是它给下游推送数据只能由一个上游 Observable 驱动（主导产生数据的节奏）只有这个上游更新才会产生一次合并推送
<blockquote><p>这个没有静态操作符，因为它需要一个做主导</p></blockquote></li> <li><code>race</code> 多个上游 Observable 一起，看谁最先产生数据，就完全采用这个的数据推送给下游，其他的会被退订</li> <li><code>forkJoin</code> 所有上游完结时，合并最后的数据产生唯一一个数据推送给下游</li> <li>高阶 Observable
<ul><li>产生的数据依然是 Observable 的 Observable 对象 -&gt; 高阶 Observable 完结了并不代表内部 Observable 对象 完结</li> <li>concatAll mergeAll zipAll combineAll
<ul><li>All 代表全部，把一个高阶 Observable 的所有内部 Observable 都组合起来</li> <li>没有任何参数，所有的输入都来自上游的 Observable 对象</li></ul></li> <li><code>switch</code> 总是切换到最新的内部 Observable 对象上获取数据
<ul><li>每当上游高阶 Observable 对象内部产生新的 Observable 就立即订阅新的，退订掉旧的</li> <li>完结条件：上游高阶 Observable 完结 + 当前内部 Observable 完结</li></ul></li> <li><code>exhaust</code> 只有耗尽当前内部 Observable 后，才<strong>有空</strong>订阅下一个新产生的内部 Observable</li></ul></li></ul> <h2 id="辅助类操作符"><a href="#辅助类操作符" aria-hidden="true" class="header-anchor">#</a> 辅助类操作符</h2> <table><thead><tr><th>功能需求</th> <th>适用的操作符</th></tr></thead> <tbody><tr><td>统计数据流中产生的所有数据个数</td> <td>count</td></tr> <tr><td>获取数据流中最大或最小的数据</td> <td>max min</td></tr> <tr><td>对数据流中所有数据做规约操作</td> <td>Reduce</td></tr> <tr><td>判断是否所有数据满足某个判定条件</td> <td>every</td></tr> <tr><td>找到第一个满足判定条件的数据</td> <td>find findIndex</td></tr> <tr><td>判断一个数据流是否不包含任何数据</td> <td>isEmpty</td></tr> <tr><td>如果一个数据流为空就默认产生一个指定的数据</td> <td>defaultIfEmpty</td></tr></tbody></table> <h2 id="过滤数据流"><a href="#过滤数据流" aria-hidden="true" class="header-anchor">#</a> 过滤数据流</h2> <table><thead><tr><th>功能需求</th> <th>适用操作符</th></tr></thead> <tbody><tr><td>过滤掉不满足判定条件的操作符</td> <td>filter</td></tr> <tr><td>获得满足判定条件的<strong>第一个</strong>数据</td> <td>first</td></tr> <tr><td>获得满足判定条件的<strong>最后一个</strong>数据</td> <td>last</td></tr> <tr><td>从数据流中选取<strong>最先出现的</strong>若干个数据</td> <td>take</td></tr> <tr><td>从数据流中选取<strong>最后出现的</strong>若干个数据</td> <td>takeLast</td></tr> <tr><td>从数据流中选取数据<strong>直到某种情况</strong>发生</td> <td>takeWhile takeUntil</td></tr> <tr><td>从数据流中<strong>忽略最先出现的</strong>若干个数据</td> <td>skip</td></tr> <tr><td>从数据流中<strong>忽略数据直到</strong>某种情况发生</td> <td>skipWhile 和 skipUntil</td></tr> <tr><td>基于数据内容的数据流筛选</td> <td>throttle debounce audit</td></tr> <tr><td>基于时间的数据流筛选</td> <td>throttleTime debounceTime auditTime</td></tr> <tr><td>基于采样方式的数据流筛选</td> <td>sample sampleTime</td></tr> <tr><td>删除重复的数据</td> <td>distnct</td></tr> <tr><td>删除重复的连续数据</td> <td>distnctUntilChanged distnctUntilKeyChanged</td></tr> <tr><td>忽略数据流中的所有数据（只关心 error 和 complete）</td> <td>ignoreElements</td></tr> <tr><td>只选取指定出现位置的数据</td> <td>elementAt</td></tr> <tr><td>判断是否只有一个数据满足条件</td> <td>single</td></tr></tbody></table> <ul><li><p><code>first</code> 与 find findIndex 的区别</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">'rxjs/add/observable/of'</span>
<span class="token keyword">import</span> <span class="token string">'rxjs/add/operator/first'</span>

<span class="token keyword">const</span> source$ <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>

source$<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> index<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 可选, 定义输出结果（数组）</span>
  <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// 可选</span>
<span class="token punctuation">)</span>
<span class="token comment">// 第二个参数可选，用于定制最终吐出的数据</span>
<span class="token comment">// 如果没有满足条件的，将会抛出 error。</span>
<span class="token comment">// 但是可以传递三个参数，表示没有结果时输出的值 -1</span>
</code></pre></div></li> <li><p><code>takeLast</code> 与 take 的差别：takeLast 只有在上游数据完结时，才能产生数据（才知道哪 n 个最后 n 个），而且时一次性传给下游（不会有时间间隔）</p></li> <li><p><code>takeUntil</code> 特点：上游的数据直接转手给下游，直到参数 notifier（是一个 Observable）吐出一个数据或者完结（-_- 它只要一有动静，takeUntil 就完结。。。</p></li> <li><p><code>takeWhile</code> <code>skipWhile</code> 的参数时一个返回 boollen 的判定函数</p></li> <li><p><code>throttleTime</code> <strong>限制</strong>在 duration 时间范围内，从上游传递给下游的数据的<strong>个数</strong>（1 个）</p></li> <li><p><code>debounceTime</code> <strong>让</strong>传递给下游的数据<strong>间隔</strong>不能小于给定的时间 duetime</p></li> <li><p><code>throttle</code> <code>debounce</code> 与上面的操作符的区别是，不是用时间来控制流量，而是用 Observable 中的数据来控制流量</p> <ul><li>参数是一个返回 Observable 的函数，可以理解成当 Observable 为固定时间吐数据时，与 throttleTime debounceTime 效果一样</li> <li>大部分场景 throttleTime debounceTime 足够，只有当固定时间的回压控制不满足要求时，才用 throttle debounce</li></ul></li> <li><p>auditTime 和 audit</p> <ul><li>auditTime 与 throttle 类似，区别是：auditTime 取时间段内的最后一个数据</li></ul></li> <li><p>sampleTime 与 sample 不管上游产生的数据节奏怎样，完全根据自己参数指定的间隔节奏来给下游传递数据</p></li></ul> <h2 id="转化数据流"><a href="#转化数据流" aria-hidden="true" class="header-anchor">#</a> 转化数据流</h2> <table><thead><tr><th>功能需求</th> <th>适用的操作符</th></tr></thead> <tbody><tr><td>将每个元素用映射函数产生新的数据</td> <td>map</td></tr> <tr><td>将数据流中每个元素映射为同一个元素</td> <td>mapTo</td></tr> <tr><td>提取数据流中每个数据的某个字段</td> <td>pluck</td></tr> <tr><td>产生高阶 Observable 对象</td> <td>windowTime windowCount windowWhen windowToggle window</td></tr> <tr><td>产生数组构成的数据流</td> <td>bufferTime bufferCount bufferWhen bufferToggle buffer</td></tr> <tr><td>映射产生高阶 Observable 对象然后合并</td> <td>concatMap mergeMap switchMap exhaustMap</td></tr> <tr><td>产生规约运算的结果组成的数据流</td> <td>scan mergeScan</td></tr></tbody></table> <ul><li>无损回压控制：把上游在一段时间内产生的数据放到一个数据集合（数组、Observable）里，然后把这个数据集合一次丢给下游。支持数组的以 <code>buffer</code> 开头，支持 <code>Observable</code> 的以 window 开头
<ul><li>windowTime 和 bufferTime 每间隔固定时间段来收集</li> <li>windowCount 和 bufferCount 每收集固定个数</li> <li>windowWhen 和 bufferWhen 参数是一个返回 Observable 的函数，Observable 的一次产生数据~完成被认为是一个“缓冲区块”</li> <li>windowToggle 和 bufferToggle 接收 2 个参数，第一个参数 opening$ 产生一个数据代表缓冲窗口（区块）的开始，同时第二个参数 <code>closingSelector</code> 被调用，用来获取缓冲窗口的结束
<blockquote><p>closingSelector 是指一个返回 Observable 的函数（它的参数是 opening$ 产生的数据）</p></blockquote></li> <li>window 和 buffer 的参数只是一个 notifer$ （吐出数据的节奏）分隔上游数据序列</li></ul></li> <li>高阶的 map
<ul><li>高阶 map 的参数（project 函数）把一个数据映射为一个 Observable 对象，而且把每个内部 Observable 的数据做组合（砸平）传给下游
<blockquote><p>project 函数 的参数（map 传下来的数据，序号）</p></blockquote></li> <li>concatMap = map + concatAll</li> <li>mergeMap = map + mergeAll</li> <li>switchMap = map + switch</li> <li>exhoustMap = map + exhoust 先产生的 Observable 优先级更高（喜欢旧的数据）</li></ul></li> <li>数据分组 - 把一个数据流拆分成多个数据流
<ul><li><code>groupBy</code> 传递给下游的是一个高阶 <code>Observable</code></li> <li><code>partition</code> 返回一个数组（包含 2 个 <code>Observable</code>）-&gt; 唯一一个不返回 Observable 的操作符</li></ul></li> <li>累计数据 规约操作
<ul><li><code>scan</code> 对上游每一个数据都会产生一个规约结果传递给下游，无需上游数据完结（与 reduce 的区别）</li> <li><code>mergeScan</code> 区别是：规约函数返回的是一个 Observable 而不是一个数据（使用频率低）</li></ul></li></ul> <h2 id="异常错误处理"><a href="#异常错误处理" aria-hidden="true" class="header-anchor">#</a> 异常错误处理</h2> <blockquote><p>对错误异常的处理可以分为 2 类：恢复（发生错误时依然让运算继续下去）、重试（重新尝试之前发生错误的操作）</p></blockquote> <table><thead><tr><th>功能需求</th> <th>适用的操作符</th></tr></thead> <tbody><tr><td>捕获并处理上游产生的异常错误</td> <td>catch</td></tr> <tr><td>当上游产生错误时进行重试</td> <td>retry retryWhen</td></tr> <tr><td>无论是否出错都要进行一些操作（上游完结 or 出错时发挥一次作用）</td> <td>finally</td></tr></tbody></table> <ul><li><code>catch</code> “恢复”</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// err: 错误对象</span>
<span class="token comment">// caught$ 代表上游 Observable 对象（直接返回 caught$ 可以模拟重试的效果）</span>
<span class="token comment">// 返回的 observable 吐出的数据会替代发生错误的那一个数据</span>
<span class="token keyword">const</span> catch$ <span class="token operator">=</span> error$<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> caught$</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Observable<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><code>retry</code> &quot;重试&quot;（本质是重新订阅一次上游的 Observable，在订阅的同时取消上一次订阅，对于 Hot 数据流其实并不是真的 “重试”，只不过是重新订阅而已）</li> <li><code>retryWhen</code> 参数是一个返回 OBservable 的函数（notice$ 节奏控制器）</li></ul> <h2 id="多播"><a href="#多播" aria-hidden="true" class="header-anchor">#</a> 多播</h2> <blockquote><p>让一个数据流的内容被多个 Observer 订阅
<code>Subject</code> <code>BehaviorSubject</code> <code>ReplaySubject</code> <code>AsyncSubject</code> 类型</p></blockquote> <table><thead><tr><th>功能需求</th> <th>适用的操作符</th></tr></thead> <tbody><tr><td>灵活选取 Subject 对象进行多播</td> <td>multicast share publish</td></tr> <tr><td>只多播数据流中最后一个数据</td> <td>publishLast</td></tr> <tr><td>对数据流中给定数量的数据进行多播</td> <td>publishReplay</td></tr> <tr><td>拥有默认数据的多播</td> <td>publishBehavior</td></tr></tbody></table> <ul><li><p>Hot Clod 数据流</p> <ul><li>Hot 操作符的数据源来自外部，实现的是 <strong>多播</strong></li> <li>Clod 实现的是单播（每次订阅都是重新发数据）</li></ul></li> <li><p><code>Subject</code> 包装 Clod 产生一个新的 Hot</p> <ul><li><strong>Subject 实例</strong>命名通常不以 $ 结尾</li> <li>Subject 兼具 Observable 和 Observer 的性质 -&gt; 实现多播效果</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Subject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/Subject'</span>
<span class="token keyword">const</span> sub1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// sub1.subscribe(...) // 接受订阅</span>
<span class="token comment">// sub1.next(1) 发数据 -&gt; 所以它调用 error complete 之后作为 Observable 的生命周期也就结束了</span>
<span class="token keyword">const</span> sub2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
source$<span class="token punctuation">.</span><span class="token function">subcribe</span><span class="token punctuation">(</span>sub2<span class="token punctuation">)</span>
<span class="token comment">// source2$.subcribe(sub2) -&gt; 它可以有多个上游来发数据</span>
<span class="token comment">// sub2.subscribe(...)</span>
<span class="token comment">// sub2.subscribe(...) // 使 source$ 多播效果</span>
</code></pre></div></li> <li><p><code>multicast</code> （比较基础的操作符</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// multicast 参数还可以是一个返回 Subject（中间人）的函数</span>
<span class="token comment">// -&gt; 当有人订阅但中间人已经退订时，产生一个新的中间人</span>
<span class="token keyword">const</span> hotSource$ <span class="token operator">=</span> coldSource$<span class="token punctuation">.</span><span class="token function">multicast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// hotSource$.connect() 开始播</span>
<span class="token comment">// 或者 hotSource$ = hotSource$.refCount() 根据下游 Observer 的个数来决定对上游的连接</span>
</code></pre></div><ul><li><code>publish</code> 是通过 <code>multicast</code> 来实现的</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// publish -&gt; multicast(new Subject())</span>
<span class="token keyword">const</span> hotSource$ <span class="token operator">=</span> coldSource$<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">refCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><code>share</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// share -&gt; multicast(() =&gt; new Subject()).refCount()</span>
<span class="token keyword">const</span> hotSource$ <span class="token operator">=</span> coldSource$<span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><code>publishLast</code> 和 <code>AsyncSubject</code> <ul><li>当上游 Cold 完结的时候，才把最后一个数据传给 Observer</li></ul></li> <li><code>publishReplay</code> 和 <code>ReplaySubject</code> TODO:</li> <li><code>publishBehavior</code> 和 <code>BehaviorSubject</code> TODO:</li></ul> <h2 id="掌握时间的-scheduler"><a href="#掌握时间的-scheduler" aria-hidden="true" class="header-anchor">#</a> 掌握时间的 Scheduler</h2> <h2 id="rxjs-调试和测试"><a href="#rxjs-调试和测试" aria-hidden="true" class="header-anchor">#</a> RxJS 调试和测试</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/Typescript 扫盲.html" class="prev">
        Typescript 扫盲
      </a></span> <span class="next"><a href="/blog/PWA.html">
        PWA 相关知识点
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.da05fdbf.js" defer></script><script src="/assets/js/2.208295da.js" defer></script><script src="/assets/js/17.eafc6cc3.js" defer></script><script src="/assets/js/5.b3cdef39.js" defer></script>
  </body>
</html>
